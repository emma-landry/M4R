---
title: "Grouping Counties"
author: "Emma Landry"
date: "2/17/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(here)
library(readxl)
library(tidyr)
library(zoo)
library(stringr)
library(dplyr)
```

```{r}
here::here()
```
We start by generation our population data set.

```{r}
pop<- read_excel(here("data","county_adjacency", "co-est2019-annres.xlsx"))
colnames <- pop[3,] #set the column names
colnames[1] <- "Geographic Area" #rename first entry
colnames(pop) <- colnames

pop <- pop[-c(1,2,3),] #remove first three rows which don't contain data
pop$`Geographic Area`<- sub('.', '', pop$`Geographic Area`) #remove the added fullstop at the beginning of each entry
pop <- pop[-c(1, 3144,3145, 3146, 3147, 3148, 3149),] #remove last rows that don't contain data
pop<- separate(pop, `Geographic Area`, sep = ",", into = c("county", "state")) #separate into county and state
```

```{r}
pop_2019 <- data.frame(pop$county, pop$state, pop$`2019`)# data set with only 2019 population
colnames(pop_2019) <- c("county", "state", "population")
pop_2019$state<- sub('.', '', pop$state)#remove the space at the front of each entry
pop_2019 <- subset( pop_2019, state!= "Hawaii" & state != "District of Columbia") #remove hawai as problem with adjacency
pop_2019 <- rbind(pop_2019[1:2910,],c("Bedford city", "Virginia", 78997),pop_2019[-(1:2910),]) #add population for Bedford, VA which was missing
```


Now prepare the adjacency data
```{r}
adj <- read.csv(here("data","county_adjacency", "county_adjacency2010.csv"), header = TRUE)
colnames(adj)<- c("county_name", "county_fips", "neighbor_name", "neighbor_fips") #rename columns
adj <- separate(adj, county_name , sep = ", ", into = c("county", "state")) #separate into county and state
adj <- subset(adj, state != "VI"& state != "PR" & state != "MP"& state != "GU" & state != "AS" & state!= "HI" & state!= "DC") #remove Hawaii and territories

adj <- separate(adj, neighbor_name, sep = ", ", into = c("neighbor_county", "neighbor_state"))
```

We notice there are some problems with the data. Start with fixing Minnesota.
```{r}
index <- adj$county_fips ==27165
adj$county[index] <- "Watonwan County"

index <- adj$county_fips ==27111
adj$county[index] <- "Otter Tail County"
```

Fixing Alaska:

```{r}
index <- adj$county_fips == 2270
adj$county[index] <- "Kusilvak Census Area"
adj$county_fips[index] <- 2158

index <- adj$neighbor_fips ==2270
adj$neighbor_county[index] <- "Kusilvak Census Area"
adj$neighbor_fips[index] <- 2158

index<- adj$county_fips== 2195
adj$county[index] <- "Petersburg Borough"

index <- adj$neighbor_fips ==2195
adj$neighbor_county[index] <- "Petersburg Borough"

```

Fixing Louisiana :
```{r}
index <- adj$county_fips== 22059
adj$county[index] <- "LaSalle Parish"

index <- adj$neighbor_fips==22059
adj$neighbor_county[index] <- "LaSalle Parish"
```

New Mexico:
```{r}
index <- adj$county_fips == 35013 
adj$county[index] = "Doña Ana County"

index <- adj$neighbor_fips == 35013
adj$neighbor_county[index] ="Doña Ana County"
```

North Dakota:
```{r}
index <- pop_2019$county == "ottineau County"
pop_2019$county[index] = "Bottineau County"
```

South Dakota:
```{r}
index <- adj$county_fips== 46113
adj$county[index] <- "Oglala Lakota County"
adj$county_fips[index] <- 46102

index <- adj$neighbor_fips== 46113
adj$neighbor_county[index] <- "Oglala Lakota County"
adj$neighbor_fips[index] <- 46102
```


We start with only looking at California (can then generalize for other states)
```{r}
calif_pop <- subset(pop_2019, state == "California")
adj_calif <- subset (adj, state == "CA")

adj_calif <- subset(adj_calif, county_fips != neighbor_fips)
adj_calif <- subset(adj_calif, neighbor_state == "CA")
```

```{r}
counties1 <- calif_pop$county
counties2 <- unique(adj_calif$county)
sum(counties1==counties2)/ length(counties1)
```

```{r}
california <-left_join(adj_calif, calif_pop, by = "county")
california <- data.frame(california$county, california$county_fips, california$population, california$neighbor_county, california$neighbor_fips)
colnames(california) <- c("county", "county_fips", "population", "neighbor_county", "neighbor_fips")

california <- left_join(california, calif_pop, by = c("neighbor_county"="county"))
cnames <- colnames(california)
cnames[3] <- "population"
cnames[7] <- "neighbor_population"
colnames(california) <- cnames
california$state <- NULL
```

```{r}
nrow(subset(calif_pop, population >150000))
nrow(calif_pop)
```


```{r}
california_copy <- california
california_copy$population <- as.numeric(california_copy$population)
min_pop <- min(california_copy$population)
min_c <- california_copy[which.min(california_copy$population),]$county
i =1
while (min_pop <= 150000){
  i = i+1
  min_c <- california_copy[which.min(california_copy$population),]$county
  min_fips <-california_copy[which.min(california_copy$population),]$county_fips
  
  #Choose the neighbour with lowest population to merge
  tmp <- subset(california_copy, county == min_c)
  min_neighbor <- tmp[which.min(tmp$neighbor_population),]$neighbor_county
  min_neighbor_fips <- tmp[which.min(tmp$neighbor_population),]$neighbor_fips
  group <- c(min_fips, min_neighbor_fips)
  
  
  tmp <- subset (california_copy, county== min_c | county == min_neighbor)
  tmp <- subset (tmp , neighbor_county != min_c & neighbor_county != min_neighbor)
  string <- paste("Group", i)
  tmp$county <- rep(string, nrow(tmp))
  tmp$population <- rep ((tmp$population[1]+ tmp$population[nrow(tmp)]),nrow(tmp))
  
  tmp$county_fips <- rep(list(group), nrow(tmp))
  tmp <- unique(tmp)
  
  california_copy<- subset(california_copy, county != min_c & county != min_neighbor)
  california_copy <- rbind(california_copy, tmp)
  
  #We need to remove the grouped county as neighbor from others
  nrowmin<- length(california_copy$neighbor_fips[california_copy$neighbor_county == min_c] )
  nrowminneigh <- length(california_copy$neighbor_fips[california_copy$neighbor_county == min_neighbor])
  
  california_copy$neighbor_fips[california_copy$neighbor_county == min_c] <- rep(list(group),nrowmin)
  california_copy$neighbor_fips[california_copy$neighbor_county == min_neighbor] <- rep(list(group), nrowminneigh)
  
  california_copy$neighbor_population[california_copy$neighbor_county == min_c] <- rep(tmp$population[1], nrowmin)
  california_copy$neighbor_population[california_copy$neighbor_county == min_neighbor] <- rep(tmp$population[1], nrowminneigh)
  
  california_copy$neighbor_county[california_copy$neighbor_county == min_c] <- rep(string, nrowmin)
  california_copy$neighbor_county[california_copy$neighbor_county == min_neighbor] <- rep(string, nrowminneigh)
  
  california_copy= unique(california_copy)
  
  min_pop <- min(california_copy$population)
  
   
}
```

```{r}
california_groups <- unique(subset(california_copy, select= -c(neighbor_county, neighbor_fips,neighbor_population)))
```

```{r}
#First data-preprocessing step
grouping_state <- function(cap,short){
  
  state_pop <- subset(pop_2019, state == cap) #select population data using capitalized full state name
  adj_state <- subset (adj, state == short) #select adjency using two letter state code

  adj_state <- subset(adj_state, county_fips != neighbor_fips) #remove each county from its own neighbors
  adj_state <- subset(adj_state, neighbor_state == short) #remove adjacent counties from diff state
  
  return(list(state_pop, adj_state))
}

```

```{r}
#Combines the data into one data frame
grouping_step2 <- function(cap, short){
  #Pre-process data using grouping_state
  state_pop <- grouping_state(cap, short)[[1]]
  adj_state <- grouping_state(cap, short)[[2]]
  
  #join the two data frames and clean it
  state_df <-left_join(adj_state, state_pop, by = "county")
  state_df <- data.frame(state_df$county, state_df$county_fips, state_df$population, state_df$neighbor_county, state_df$neighbor_fips)
  colnames(state_df) <- c("county", "county_fips", "population", "neighbor_county", "neighbor_fips")
  
  state_df <- left_join(state_df, state_pop, by = c("neighbor_county"="county"))
  cnames <- colnames(state_df)
  cnames[3] <- "population"
  cnames[7] <- "neighbor_population"
  colnames(state_df) <- cnames
  state_df$state <- NULL
  
  return(state_df)
}
```

```{r}
#Obtain the groupings
do_groups <- function(cap,short, tol){
  #Obtain fully prepared data frame
  state_df <- grouping_step2(cap, short)
  
  state_df$population <- as.numeric(state_df$population)
  min_pop <- min(state_df$population) #lowest population
  min_c <- state_df[which.min(state_df$population),]$county #index of county with lowest population
  i =1
  
  #iterate as long as some groupings have population less than tol
  while (min_pop <= tol){
    i = i+1
    min_c <- state_df[which.min(state_df$population),]$county #less populated county
    min_fips <-state_df[which.min(state_df$population),]$county_fips #fips of less populated county
    
    #Choose the neighbour with lowest population to merge
    tmp <- subset(state_df, county == min_c)
    min_neighbor <- tmp[which.min(tmp$neighbor_population),]$neighbor_county
    min_neighbor_fips <- tmp[which.min(tmp$neighbor_population),]$neighbor_fips
    group <- c(min_fips, min_neighbor_fips)
    
    tmp <- subset (state_df, county== min_c | county == min_neighbor)
    tmp <- subset (tmp , neighbor_county != min_c & neighbor_county != min_neighbor)
    string <- paste("Group", i)
    tmp$county <- rep(string, nrow(tmp))
    tmp$population <- rep ((tmp$population[1]+ tmp$population[nrow(tmp)]),nrow(tmp))
    
    tmp$county_fips <- rep(list(group), nrow(tmp))
    tmp <- unique(tmp)
    
    state_df<- subset(state_df, county != min_c & county != min_neighbor)
    state_df <- rbind(state_df, tmp)
    
    #We need to remove the grouped county as neighbor from others
    nrowmin<- length(state_df$neighbor_fips[state_df$neighbor_county == min_c] )
    nrowminneigh <- length(state_df$neighbor_fips[state_df$neighbor_county == min_neighbor])
    
    state_df$neighbor_fips[state_df$neighbor_county == min_c] <- rep(list(group),nrowmin)
    state_df$neighbor_fips[state_df$neighbor_county == min_neighbor] <- rep(list(group), nrowminneigh)
    
    state_df$neighbor_population[state_df$neighbor_county == min_c] <- rep(tmp$population[1], nrowmin)
    state_df$neighbor_population[state_df$neighbor_county == min_neighbor] <- rep(tmp$population[1], nrowminneigh)
    
    state_df$neighbor_county[state_df$neighbor_county == min_c] <- rep(string, nrowmin)
    state_df$neighbor_county[state_df$neighbor_county == min_neighbor] <- rep(string, nrowminneigh)
    
    state_df= unique(state_df)
    
    min_pop <- min(state_df$population)
  }
  return(state_df)
}
```

```{r}
california_copy
```

```{r}
cap = "Texas"
short = "TX"
a<- unique(subset(do_groups(cap, short, 150000), select= -c(neighbor_county, neighbor_fips,neighbor_population)))

b<- grouping_step2(cap, short)
length(unique(b$county))

fips = c()
for (i in seq(1:nrow(a))){
  fips = c(fips,unlist(a$county_fips[i]))
}
length(fips)
length(unique(fips))
```

```{r}
x =1
for (i in unique(pop_2019$state)){
  cap = i
  short = unique(adj$state) [x]
  print(cap)
  print(grouping_state(cap, short))
  x = x+1
}
```

```{r}
pop_counties <-unique( grouping_state("Alaska", "AK", comp = FALSE, dataset= TRUE)[[1]]$county)

adj_counties  <-unique(grouping_state("Alaska", "AK", comp = FALSE, dataset= TRUE)[[2]]$county)

str_sort(pop_counties)==str_sort(adj_counties)
str_sort(pop_counties)[9:22]
str_sort(adj_counties)[9:22]


```

```{r}
unique(pop_2019$state)
unique(adj$state)
```


```{r}
saveRDS(california_groups, here("data", "grouped_counties", "california_groups.rds"))
```

```{r}
pennsyvalnia_groups <- do_groups("Pennsylvania", "PA", 150000)
pennsyvalnia_groups <- unique(subset(pennsyvalnia_groups, select= -c(neighbor_county, neighbor_fips,neighbor_population)))
saveRDS(pennsyvalnia_groups, here("data", "grouped_counties", "pennsylvania_groups.rds"))
```

```{r}
alaska_groups <- do_groups("Alaska", "AK", 150000)
alaska_groups <- unique(subset(alaska_groups, select= -c(neighbor_county, neighbor_fips,neighbor_population)))
saveRDS(alaska_groups, here("data", "grouped_counties", "alaska_groups.rds"))
```

```{r}
south_dakota_groups <- do_groups("South Dakota", "SD", 150000)
south_dakota_groups <- unique(subset(south_dakota_groups, select= -c(neighbor_county, neighbor_fips,neighbor_population)))
saveRDS(south_dakota_groups, here("data", "grouped_counties", "south_dakota_groups.rds"))
```


```{r}
nd_groups <- do_groups("North Dakota", "ND", 150000)
nd_groups <- unique(subset(nd_groups, select= -c(neighbor_county, neighbor_fips,neighbor_population)))
saveRDS(nd_groups, here("data", "grouped_counties", "north_dakota_groups.rds"))
```

```{r}
wyoming_groups <- do_groups("Wyoming", "WY", 150000)
wyoming_groups <- unique(subset(wyoming_groups, select= -c(neighbor_county, neighbor_fips,neighbor_population)))
saveRDS(nd_groups, here("data", "grouped_counties", "wyoming_groups.rds"))
```

```{r}
short_state <- unique(adj$state)
long_state <- unique(pop_2019$state)
```

```{r}
N<- length(short_state)
length(long_state)
```

```{r}
c = 0
for (i in seq (1:N)){
  state_groups <- do_groups(long_state[i], short_state[i], 150000)
  state_groups <- unique(subset(state_groups, select= -c(neighbor_county,neighbor_fips,neighbor_population)))
  c = c+ nrow(state_groups)
  print(long_state[i])
  print(nrow(state_groups))
}
```

```{r}
short_state
long_state
```

